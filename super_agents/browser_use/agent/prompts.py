from typing import List

def create_agent_prompt(
    task: str,
    current_browser_content: str, # This string now potentially contains URL, DOM, AX Tree, and Visual Elements
    history: List[str],
    error_message: str = None
) -> str:
    """
    Generates the prompt to be sent to the LLM based on the current state.
    Includes sections for Simplified DOM, Accessibility Tree, and Visual Elements.
    """
    prompt_parts = []
    prompt_parts.append("You are an AI agent controlling a web browser to complete a task.")
    prompt_parts.append(f"Your current task is: {task}")

    if error_message:
        prompt_parts.append(f"\nAn error occurred in the previous step: {error_message}")
        prompt_parts.append("Please analyze the error and the current browser state, then decide the next best action.")

    prompt_parts.append("\n\n# Current Browser Perception:")
    # The browser_content string now contains multiple sections, as generated by get_content
    prompt_parts.append(current_browser_content)

    if history:
        prompt_parts.append("\n\n# History of Previous Actions:")
        for i, item in enumerate(history[-5:], 1):
            prompt_parts.append(f"{i}. {item}")

    # --- Instructions with guidance on using all perception data ---
    instructions = """

# Instructions:
Analyze the **Current Browser Perception** section above, which includes:
1.  **Page URL:** The current web address.
2.  **Simplified DOM:** A structural view of the page with interactive elements marked with `x-pw-id` attributes.
3.  **Accessibility Tree:** Semantic information about elements (roles, names).
4.  **Visual Elements:** Elements detected visually via Computer Vision (CV), including their bounding boxes `[L:left, T:top, R:right, B:bottom]` and IDs (e.g., `cv-0`, `cv-1`).

Based on the task and ALL available perception information, decide the single next action to take.
Your response MUST be a JSON object with a single top-level key named "action".
The value of the "action" key MUST be an object matching one of the following action schemas:

- Navigate: {{"type": "navigate", "url": "<url_string>"}}
- Click: {{"type": "click", "selector": "<css_selector>", "description": "<element_description: optional>"}}
- Type: {{"type": "type", "selector": "<css_selector>", "text": "<text_to_type>", "description": "<element_description: optional>"}}
- Scroll: {{"type": "scroll", "direction": "<up|down|left|right>"}}
- Finish: {{"type": "finish", "result": "<final_answer_or_summary>"}}
- Error: {{"type": "error", "message": "<error_description>"}} (Use if you detect an unrecoverable error or loop)
- GetContent: {{"type": "get_content", "description": "<reason>"}}

**Important Task Handling Guidance:**
1.  **Identify elements** using the DOM, AX Tree (if available), and Visual Elements. Use robust selectors as previously guided.
2.  **If the task requires reading or extracting content that might extend beyond the current view (e.g., '摘录全文', 'find all items', 'read the article'), and you haven't finished scrolling, your next action should likely be to SCROLL DOWN.** Use: `{{"action": {{"type": "scroll", "direction": "down"}}}}`
3.  Only use `get_content` if you believe scrolling will not help or if you need to re-analyze after a non-scroll action.
4.  Once you believe you have scrolled enough and have all necessary information visible in the content provided, proceed with the extraction or final action.
5.  If the task is complete, use the 'finish' action.

Example Response:
```json
{{
  "action": {{
    "type": "click",
    "selector": "a[x-pw-id='pw-16']:has-text('new')",
    "description": "Click the 'new' link, corresponds to visual element cv-3"
  }}
}}
{{
  "action": {{
    "type": "scroll",
    "direction": "down"
  }}
}}
```

Provide ONLY the JSON object containing the 'action' key in a ```json ... ``` block.
Think step-by-step. Correlate information from the DOM, AX Tree, and Visual Elements if possible. Choose the most precise and stable selector.
If the task is complete, use the 'finish' action.
"""
    prompt_parts.append(instructions)
    # --- End Instructions ---

    final_prompt = "\n".join(prompt_parts)
    return final_prompt