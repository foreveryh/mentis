from typing import List

def create_agent_prompt(
    task: str,
    current_browser_content: str, # This string now potentially contains URL, DOM, AX Tree, and Visual Elements
    history: List[str],
    error_message: str = None
) -> str:
    """
    Generates the prompt to be sent to the LLM based on the current state.
    Includes sections for Simplified DOM, Accessibility Tree, and Visual Elements.
    """
    prompt_parts = []
    prompt_parts.append("You are an AI agent controlling a web browser to complete a task.")
    prompt_parts.append(f"Your current task is: {task}")

    if error_message:
        prompt_parts.append(f"\nAn error occurred in the previous step: {error_message}")
        prompt_parts.append("Please analyze the error and the current browser state, then decide the next best action.")

    prompt_parts.append("\n\n# Current Browser Perception:")
    # The browser_content string now contains multiple sections, as generated by get_content
    prompt_parts.append(current_browser_content)

    if history:
        prompt_parts.append("\n\n# History of Previous Actions:")
        for i, item in enumerate(history[-5:], 1):
            prompt_parts.append(f"{i}. {item}")

    # --- Instructions with guidance on using all perception data ---
    instructions = """

# Instructions:
Analyze the **Current Browser Perception** section above, which includes:
1.  **Page URL:** The current web address.
2.  **Simplified DOM:** A structural view of the page with interactive elements marked with `x-pw-id` attributes.
3.  **Accessibility Tree:** Semantic information about elements (roles, names).
4.  **Visual Elements:** Elements detected visually via Computer Vision (CV), including their bounding boxes `[L:left, T:top, R:right, B:bottom]` and IDs (e.g., `cv-0`, `cv-1`).

Based on the task and ALL available perception information, decide the single next action to take.
Your response MUST be a JSON object with a single top-level key named "action".
The value of the "action" key MUST be an object matching one of the following action schemas:

- Navigate: {{"type": "navigate", "url": "<url_string>"}}
- Click: {{"type": "click", "selector": "<css_selector>", "description": "<element_description: optional>"}}
- Type: {{"type": "type", "selector": "<css_selector>", "text": "<text_to_type>", "description": "<element_description: optional>"}}
- Scroll: {{"type": "scroll", "direction": "<up|down|left|right>"}}
- Finish: {{"type": "finish", "result": "<final_answer_or_summary>"}}
- Error: {{"type": "error", "message": "<error_description>"}} (Use if you detect an unrecoverable error or loop)

**Important Selector Guidance for 'click'/'type':**
1.  **Prefer Robust CSS:** Try to use stable attributes like `id`, `name`, or ARIA roles (`[role='button']`).
2.  **Combine `x-pw-id` and Text:** If using the DOM view, prefer combining `x-pw-id` with text: `a[x-pw-id='pw-16']:has-text('new')`.
3.  **Use Text:** If IDs seem unstable, use visible text: `a:has-text('new')`.
4.  **Consider Visual Elements:** If a target seems hard to select via DOM/AX, you might refer to a Visual Element ID (e.g., `cv-5`) in your reasoning or description, although the action still requires a CSS selector for Playwright execution. (Future actions might directly use coordinates if implemented).

Example Response:
```json
{{
  "action": {{
    "type": "click",
    "selector": "a[x-pw-id='pw-16']:has-text('new')",
    "description": "Click the 'new' link, corresponds to visual element cv-3"
  }}
}}
```

Provide ONLY the JSON object containing the 'action' key in a ```json ... ``` block.
Think step-by-step. Correlate information from the DOM, AX Tree, and Visual Elements if possible. Choose the most precise and stable selector.
If the task is complete, use the 'finish' action.
"""
    prompt_parts.append(instructions)
    # --- End Instructions ---

    final_prompt = "\n".join(prompt_parts)
    return final_prompt